<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Anotaciones por Pablo Caro - productividad</title><link href="https://pablocaro.es/" rel="alternate"></link><link href="https://pablocaro.es/feeds/tags/productividad.atom.xml" rel="self"></link><id>https://pablocaro.es/</id><updated>2025-12-25T15:45:00+01:00</updated><subtitle>Anotaciones</subtitle><entry><title>`fresh`: Mi editor de terminal preferido para el día a día</title><link href="https://pablocaro.es/fresh-editor-terminal" rel="alternate"></link><published>2025-12-25T15:45:00+01:00</published><updated>2025-12-25T15:45:00+01:00</updated><author><name>Pablo Caro</name></author><id>tag:pablocaro.es,2025-12-25:/fresh-editor-terminal</id><summary type="html">&lt;p&gt;Descubre &lt;code&gt;fresh&lt;/code&gt;, un editor de texto en terminal rápido, moderno y sin modos, ideal para la edición casual de archivos, superando a &lt;code&gt;nano&lt;/code&gt; y &lt;code&gt;vim&lt;/code&gt; en simplicidad para el uso habitual.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Aunque &lt;code&gt;vim&lt;/code&gt; es una herramienta increíblemente potente y &lt;code&gt;nano&lt;/code&gt; destaca por su simplicidad extrema, a menudo busco un punto intermedio para la edición de archivos en la terminal. Un editor que sea rápido, moderno y que no me obligue a recordar modos o combinaciones de teclas complejas para tareas sencillas. Así es como he descubierto &lt;strong&gt;&lt;code&gt;fresh&lt;/code&gt;&lt;/strong&gt;, y se ha convertido rápidamente en mi editor de terminal preferido para el uso diario.&lt;/p&gt;
&lt;h2 id="que-es-fresh"&gt;¿Qué es &lt;code&gt;fresh&lt;/code&gt;?&lt;a class="headerlink" href="#que-es-fresh" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fresh&lt;/code&gt; es un editor de texto para terminal diseñado para ser &lt;strong&gt;simple, rápido y eficiente&lt;/strong&gt;. A diferencia de &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;fresh&lt;/code&gt; es un editor sin modos, lo que significa que puedes empezar a escribir y editar texto inmediatamente, como lo harías en un editor gráfico. A diferencia de &lt;code&gt;nano&lt;/code&gt;, &lt;code&gt;fresh&lt;/code&gt; ofrece una experiencia más moderna con características que esperas de un editor de texto actual.&lt;/p&gt;
&lt;h2 id="por-que-lo-prefiero-a-nano-o-vim-para-mi-uso-habitual"&gt;¿Por qué lo prefiero a &lt;code&gt;nano&lt;/code&gt; o &lt;code&gt;vim&lt;/code&gt; para mi uso habitual?&lt;a class="headerlink" href="#por-que-lo-prefiero-a-nano-o-vim-para-mi-uso-habitual" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sin Modos&lt;/strong&gt;: La principal ventaja sobre &lt;code&gt;vim&lt;/code&gt;. No necesitas aprender a cambiar entre modos de inserción, normal, visual, etc. Simplemente abres el archivo y editas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Moderno y Rápido&lt;/strong&gt;: A pesar de ejecutarse en la terminal, &lt;code&gt;fresh&lt;/code&gt; se siente responsivo y ofrece una interfaz limpia.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resaltado de Sintaxis&lt;/strong&gt;: Soporte para coloreado de sintaxis para una gran variedad de lenguajes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Soporte de Ratón&lt;/strong&gt;: Puedes hacer clic para mover el cursor, seleccionar texto, o incluso usar la rueda para scroll.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multi-Cursor&lt;/strong&gt;: Una característica muy potente que &lt;code&gt;nano&lt;/code&gt; no ofrece y que &lt;code&gt;vim&lt;/code&gt; requiere más complejidad para usar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deshacer/Rehacer&lt;/strong&gt;: Funcionalidad completa de &lt;code&gt;undo&lt;/code&gt;/&lt;code&gt;redo&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Búsqueda y Reemplazo&lt;/strong&gt;: Funciones de búsqueda y reemplazo sencillas e intuitivas.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mientras que &lt;code&gt;vim&lt;/code&gt; sigue siendo mi elección para ediciones complejas o scripting avanzado, para "abrir un &lt;code&gt;.conf&lt;/code&gt;", modificar un &lt;code&gt;.bashrc&lt;/code&gt;, o escribir una pequeña nota, &lt;code&gt;fresh&lt;/code&gt; es imbatible en velocidad y comodidad. &lt;code&gt;nano&lt;/code&gt; es quizás demasiado básico para mis necesidades, careciendo de la mayoría de las características modernas que &lt;code&gt;fresh&lt;/code&gt; ofrece.&lt;/p&gt;
&lt;h2 id="instalacion"&gt;Instalación&lt;a class="headerlink" href="#instalacion" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fresh&lt;/code&gt; es fácil de instalar en la mayoría de las distribuciones Linux. Por ejemplo, en sistemas basados en Debian/Ubuntu:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;fresh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;O puedes seguir las instrucciones del repositorio oficial para compilarlo desde el código fuente o usar otros gestores de paquetes.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusión&lt;a class="headerlink" href="#conclusion" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Si buscas un editor de terminal que sea un híbrido perfecto entre la potencia de &lt;code&gt;vim&lt;/code&gt; y la simplicidad de &lt;code&gt;nano&lt;/code&gt;, pero con un toque moderno y centrado en la usabilidad inmediata, &lt;code&gt;fresh&lt;/code&gt; es una excelente opción. Dale una oportunidad, ¡podría convertirse en tu nuevo favorito!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Repositorio oficial&lt;/em&gt;: &lt;a href="https://sinelaw.github.io/fresh/"&gt;&lt;code&gt;fresh&lt;/code&gt; en GitHub&lt;/a&gt;&lt;/p&gt;</content><category term="Herramientas"></category><category term="fresh"></category><category term="terminal"></category><category term="editor"></category><category term="productividad"></category><category term="linux"></category><category term="herramientas"></category><category term="cli"></category></entry><entry><title>Kooha: Captura de pantalla sencilla y elegante en Linux</title><link href="https://pablocaro.es/kooha-captura-pantalla-linux" rel="alternate"></link><published>2025-12-25T15:00:00+01:00</published><updated>2025-12-25T15:00:00+01:00</updated><author><name>Pablo Caro</name></author><id>tag:pablocaro.es,2025-12-25:/kooha-captura-pantalla-linux</id><summary type="html">&lt;p&gt;Descubre Kooha, una aplicación de grabación de pantalla minimalista para Linux que combina facilidad de uso con funcionalidades esenciales.&lt;/p&gt;</summary><content type="html">&lt;p&gt;En Linux, la necesidad de grabar la pantalla de forma sencilla y eficiente es común, ya sea para crear tutoriales, presentaciones, reportes de bugs o simplemente compartir una experiencia. Aunque existen muchas herramientas, &lt;strong&gt;Kooha&lt;/strong&gt; destaca por su enfoque minimalista y su interfaz de usuario intuitiva, basada en GTK.&lt;/p&gt;
&lt;h2 id="que-es-kooha"&gt;¿Qué es Kooha?&lt;a class="headerlink" href="#que-es-kooha" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Kooha es una aplicación de grabación de pantalla gratuita y de código abierto, diseñada específicamente para entornos de escritorio Linux. Su objetivo principal es ofrecer una experiencia de usuario sin complicaciones, enfocándose en las funcionalidades esenciales de una grabadora de pantalla.&lt;/p&gt;
&lt;h2 id="por-que-elegir-kooha"&gt;¿Por qué elegir Kooha?&lt;a class="headerlink" href="#por-que-elegir-kooha" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Facilidad de Uso&lt;/strong&gt;: Su interfaz es clara y directa. No hay menús complejos ni opciones abrumadoras, lo que la hace ideal para usuarios de todos los niveles.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Diseño Minimalista&lt;/strong&gt;: Se integra perfectamente con el aspecto de GNOME y otros entornos GTK, ofreciendo una experiencia visual limpia y agradable.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Funcionalidades Clave&lt;/strong&gt;: A pesar de su simplicidad, incluye todas las opciones necesarias para la mayoría de las tareas de grabación.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Código Abierto&lt;/strong&gt;: Al ser open-source, se beneficia de la comunidad y permite a los usuarios inspeccionar y contribuir al código.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="caracteristicas-principales"&gt;Características Principales&lt;a class="headerlink" href="#caracteristicas-principales" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Grabación de Pantalla Completa&lt;/strong&gt;: Captura todo lo que ocurre en tu monitor.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Grabación de Ventana Específica&lt;/strong&gt;: Elige una aplicación o ventana en particular para grabar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Grabación de Área Seleccionada&lt;/strong&gt;: Define un área rectangular en tu pantalla para la captura.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Grabación de Audio&lt;/strong&gt;: Incluye audio desde tu micrófono.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Grabación de Webcam&lt;/strong&gt;: Integra la imagen de tu cámara web en la grabación.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Formatos Comunes&lt;/strong&gt;: Soporte para formatos populares como WebM y MP4.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Opciones de Calidad&lt;/strong&gt;: Ajustes para la tasa de fotogramas (FPS) y la calidad del video.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="instalacion"&gt;Instalación&lt;a class="headerlink" href="#instalacion" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;La forma más recomendada de instalar Kooha es a través de Flatpak, lo que asegura que obtendrás la última versión y todas las dependencias necesarias:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;flatpak&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;flathub&lt;span class="w"&gt; &lt;/span&gt;com.github.SeaDve.Kooha
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;También puede estar disponible en los repositorios de algunas distribuciones Linux o como paquete Snap.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusión&lt;a class="headerlink" href="#conclusion" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Kooha es la herramienta perfecta para quienes buscan una solución de grabación de pantalla en Linux que sea potente sin ser complicada. Su elegancia y sencillez la convierten en una excelente adición al arsenal de productividad de cualquier usuario de Linux.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Repositorio oficial&lt;/em&gt;: &lt;a href="https://github.com/SeaDve/Kooha"&gt;SeaDve/Kooha en GitHub&lt;/a&gt;&lt;/p&gt;</content><category term="Herramientas"></category><category term="linux"></category><category term="kooha"></category><category term="screen-recorder"></category><category term="productividad"></category><category term="herramientas"></category><category term="open-source"></category></entry><entry><title>`direnv`: Gestiona tus entornos de desarrollo de forma inteligente</title><link href="https://pablocaro.es/direnv-gestion-entornos" rel="alternate"></link><published>2025-12-25T14:30:00+01:00</published><updated>2025-12-25T14:30:00+01:00</updated><author><name>Pablo Caro</name></author><id>tag:pablocaro.es,2025-12-25:/direnv-gestion-entornos</id><summary type="html">&lt;p&gt;Descubre &lt;code&gt;direnv&lt;/code&gt;, una extensión de shell que carga y descarga variables de entorno automáticamente al cambiar de directorio, manteniendo tu configuración limpia y organizada.&lt;/p&gt;</summary><content type="html">&lt;p&gt;En el día a día de un desarrollador, es común trabajar con múltiples proyectos, cada uno con sus propias variables de entorno, rutas (&lt;code&gt;PATH&lt;/code&gt;), versiones de herramientas o credenciales. La gestión manual de estas variables puede llevar a configuraciones desordenadas en tu &lt;code&gt;.profile&lt;/code&gt; o &lt;code&gt;.bashrc&lt;/code&gt;, o a errores por usar el entorno incorrecto. Aquí es donde &lt;strong&gt;&lt;code&gt;direnv&lt;/code&gt;&lt;/strong&gt; brilla, ofreciendo una solución elegante y automática.&lt;/p&gt;
&lt;h2 id="que-es-direnv"&gt;¿Qué es &lt;code&gt;direnv&lt;/code&gt;?&lt;a class="headerlink" href="#que-es-direnv" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;direnv&lt;/code&gt; es una extensión para tu shell (Bash, Zsh, Fish, etc.) que detecta automáticamente cuando cambias de directorio. Cuando entras en un directorio que contiene un archivo &lt;code&gt;.envrc&lt;/code&gt;, &lt;code&gt;direnv&lt;/code&gt; lo carga; cuando sales de él, lo descarga. Esto significa que tu entorno de shell se adapta dinámicamente a tu proyecto actual, sin que tengas que hacer nada manualmente.&lt;/p&gt;
&lt;h2 id="como-funciona"&gt;¿Cómo funciona?&lt;a class="headerlink" href="#como-funciona" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;direnv&lt;/code&gt; se integra con tu shell a través de un &lt;em&gt;hook&lt;/em&gt; en el comando &lt;code&gt;cd&lt;/code&gt;. Cada vez que cambias de directorio, &lt;code&gt;direnv&lt;/code&gt; comprueba si existe un archivo &lt;code&gt;.envrc&lt;/code&gt; en el directorio actual o en alguno de sus ancestros. Si encuentra uno (y le has dado permiso para cargarlo), ejecuta los comandos definidos en ese archivo para modificar tu entorno. Al salir del directorio, revierte esos cambios, limpiando tu entorno.&lt;/p&gt;
&lt;h2 id="casos-de-uso-comunes"&gt;Casos de Uso Comunes&lt;a class="headerlink" href="#casos-de-uso-comunes" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Gestión de &lt;code&gt;PATH&lt;/code&gt;&lt;/strong&gt;: Añadir binarios específicos de un proyecto a tu &lt;code&gt;PATH&lt;/code&gt; temporalmente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Entornos Virtuales de Python&lt;/strong&gt;: Activar automáticamente un &lt;code&gt;virtualenv&lt;/code&gt; o &lt;code&gt;uv venv&lt;/code&gt; al entrar en un proyecto Python.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Credenciales y Claves API&lt;/strong&gt;: Cargar variables de entorno con credenciales de bases de datos, claves API o tokens de forma segura (sin que queden en el historial del shell).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Variables de Entorno Específicas del Proyecto&lt;/strong&gt;: &lt;code&gt;RAILS_ENV&lt;/code&gt;, &lt;code&gt;NODE_ENV&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cambio de Versiones de Herramientas&lt;/strong&gt;: Integrar con herramientas como &lt;code&gt;nvm&lt;/code&gt; o &lt;code&gt;pyenv&lt;/code&gt; para cambiar automáticamente de versión de Node.js o Python.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="instalacion-basica-ejemplo-para-bash"&gt;Instalación Básica (ejemplo para Bash)&lt;a class="headerlink" href="#instalacion-basica-ejemplo-para-bash" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Instalar &lt;code&gt;direnv&lt;/code&gt;&lt;/strong&gt;: Puedes instalarlo desde tu gestor de paquetes (&lt;code&gt;sudo apt install direnv&lt;/code&gt;, &lt;code&gt;brew install direnv&lt;/code&gt;, etc.).&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Activar el hook en tu shell&lt;/strong&gt;: Añade la siguiente línea a tu &lt;code&gt;~/.bashrc&lt;/code&gt; (o &lt;code&gt;~/.zshrc&lt;/code&gt;):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
eval "$(direnv hook bash)"&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Crear un archivo &lt;code&gt;.envrc&lt;/code&gt;&lt;/strong&gt;: En la raíz de tu proyecto, crea un archivo &lt;code&gt;.envrc&lt;/code&gt; con las variables y comandos que quieras.&lt;/p&gt;
&lt;p&gt;```bash&lt;/p&gt;
&lt;h1 id="envrc-en-la-raiz-de-tu-proyecto-python"&gt;.envrc en la raíz de tu proyecto Python&lt;a class="headerlink" href="#envrc-en-la-raiz-de-tu-proyecto-python" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;layout python  # Activa automáticamente un entorno virtual
export MY_API_KEY="super_secreto_del_proyecto"
```&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Permitir la carga&lt;/strong&gt;: La primera vez que entres al directorio con un nuevo &lt;code&gt;.envrc&lt;/code&gt;, &lt;code&gt;direnv&lt;/code&gt; te pedirá confirmación:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
direnv: error .envrc is blocked. Run `direnv allow` to approve its contents&lt;/code&gt;
Ejecuta &lt;code&gt;direnv allow&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="la-libreria-estandar-de-direnv"&gt;La Librería Estándar de &lt;code&gt;direnv&lt;/code&gt;&lt;a class="headerlink" href="#la-libreria-estandar-de-direnv" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;direnv&lt;/code&gt; viene con una potente librería estándar que incluye funciones predefinidas para tareas comunes, como &lt;code&gt;layout python&lt;/code&gt; (para gestionar virtualenvs), &lt;code&gt;use nix&lt;/code&gt;, &lt;code&gt;use node&lt;/code&gt;, etc., simplificando enormemente la configuración de tus &lt;code&gt;.envrc&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="beneficios-clave"&gt;Beneficios Clave&lt;a class="headerlink" href="#beneficios-clave" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Entornos limpios&lt;/strong&gt;: Tu &lt;code&gt;.profile&lt;/code&gt; permanece ordenado.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consistencia&lt;/strong&gt;: Cada proyecto tiene exactamente el entorno que necesita.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Productividad&lt;/strong&gt;: No más &lt;code&gt;source venv/bin/activate&lt;/code&gt; manual o recordar configurar variables.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;direnv&lt;/code&gt; es una herramienta pequeña pero poderosa que transforma la forma en que gestionas tus entornos de desarrollo, haciendo tu vida en la terminal mucho más eficiente y libre de errores.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Artículo original&lt;/em&gt;: &lt;a href="https://direnv.net/"&gt;&lt;code&gt;direnv&lt;/code&gt; homepage&lt;/a&gt;&lt;/p&gt;</content><category term="Herramientas"></category><category term="direnv"></category><category term="shell"></category><category term="entorno"></category><category term="productividad"></category><category term="desarrollo"></category><category term="linux"></category><category term="herramientas"></category></entry><entry><title>Kitty como terminal de acceso rápido: La comodidad de un desplegable</title><link href="https://pablocaro.es/kitty-acceso-rapido" rel="alternate"></link><published>2025-12-25T12:30:00+01:00</published><updated>2025-12-25T12:30:00+01:00</updated><author><name>Pablo Caro</name></author><id>tag:pablocaro.es,2025-12-25:/kitty-acceso-rapido</id><summary type="html">&lt;p&gt;Configura Kitty para un acceso instantáneo y eficiente, combinando la potencia de un terminal moderno con la conveniencia de un desplegable.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Una de las características más apreciadas de terminales como Yakuake o Guake es su capacidad para aparecer y desaparecer instantáneamente con una sola pulsación de tecla, ofreciendo un acceso rápido sin interrumpir el flujo de trabajo. &lt;strong&gt;Kitty&lt;/strong&gt;, el terminal acelerado por GPU, también puede replicar y mejorar esta experiencia, combinando su potencia con la comodidad de un terminal desplegable.&lt;/p&gt;
&lt;h2 id="el-concepto-del-terminal-desplegable"&gt;El Concepto del Terminal Desplegable&lt;a class="headerlink" href="#el-concepto-del-terminal-desplegable" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;La idea es simple: un terminal que reside en segundo plano y se muestra u oculta a demanda. Esto es especialmente útil para comandos rápidos, monitoreo o cualquier tarea que requiera una interacción breve con la línea de comandos.&lt;/p&gt;
&lt;h2 id="kitty-para-acceso-rapido"&gt;Kitty para Acceso Rápido&lt;a class="headerlink" href="#kitty-para-acceso-rapido" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Kitty no tiene una función de "desplegable" nativa como Yakuake, pero su flexibilidad y capacidades de scripting permiten configurarlo para este propósito. La clave reside en:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Instancias de Kitty dedicadas:&lt;/strong&gt; Puedes lanzar una instancia de Kitty en un "daemon" o en segundo plano, lista para ser activada.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Control remoto:&lt;/strong&gt; Kitty ofrece un protocolo de control remoto (&lt;code&gt;kitty @&lt;/code&gt;) que permite interactuar con instancias ya abiertas.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gestor de ventanas:&lt;/strong&gt; Usar las reglas de tu gestor de ventanas (KDE, Gnome, i3, Sway, etc.) para asignar una tecla de acceso rápido que muestre u oculte la ventana de Kitty.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="configuracion-de-ejemplo"&gt;Configuración de Ejemplo&lt;a class="headerlink" href="#configuracion-de-ejemplo" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Aquí tienes un enfoque conceptual para lograr un terminal de acceso rápido con Kitty y un gestor de ventanas (por ejemplo, con &lt;code&gt;xdotool&lt;/code&gt; para entornos Xorg, o funciones similares en Wayland):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lanzar Kitty en segundo plano:&lt;/strong&gt;
    Puedes tener una instancia de Kitty que se inicie automáticamente con tu sesión y que esté configurada para ser "flotante" y con un tamaño específico.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Script de alternancia (toggle):&lt;/strong&gt;
    Crear un pequeño script que compruebe si la ventana de Kitty "siempre visible" está activa y, si lo está, la oculte; si no lo está, la muestre.&lt;/p&gt;
&lt;p&gt;```bash&lt;/p&gt;
&lt;h1 id="binbash"&gt;!/bin/bash&lt;a class="headerlink" href="#binbash" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;KITTY_CLASS="kitty-dropdown" # Una clase personalizada para la ventana de Kitty
KITTY_ID=$(xdotool search --class "$KITTY_CLASS" | head -n 1)&lt;/p&gt;
&lt;p&gt;if [ -z "$KITTY_ID" ]; then
    # Si no existe, lanzarla
    kitty --class "$KITTY_CLASS" &amp;amp;
else
    # Si existe, alternar visibilidad
    if xdotool getwindowfocus getwindowpid | grep -q "$(xdotool getwindowpid "$KITTY_ID")"; then
        xdotool windowminimize "$KITTY_ID"
    else
        xdotool windowmap "$KITTY_ID" # Mostrar la ventana
        xdotool windowraise "$KITTY_ID" # Asegurarse de que esté al frente
        xdotool windowfocus "$KITTY_ID" # Darle el foco
    fi
fi
```&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Atajo de teclado en tu gestor de ventanas:&lt;/strong&gt;
    Asigna una tecla global (por ejemplo, &lt;code&gt;F12&lt;/code&gt;) para ejecutar este script.&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;h1 id="ejemplo-en-configi3config-o-similar"&gt;Ejemplo en ~/.config/i3/config o similar&lt;a class="headerlink" href="#ejemplo-en-configi3config-o-similar" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;bindsym $mod+F12 exec --no-startup-id /path/to/your/toggle-kitty-dropdown.sh
```&lt;/p&gt;
&lt;p&gt;Y en tu &lt;code&gt;kitty.conf&lt;/code&gt;, puedes configurar la instancia de Kitty para que tenga la clase específica y una posición/tamaño adecuados:&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;h1 id="kittyconf-configuracion-para-la-instancia-dropdown"&gt;kitty.conf (configuración para la instancia dropdown)&lt;a class="headerlink" href="#kittyconf-configuracion-para-la-instancia-dropdown" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;window_class_members kitty-dropdown
initial_window_width 80%
initial_window_height 40%
window_border_width 0&lt;/p&gt;
&lt;h1 id="otras-configuraciones-de-apariencia"&gt;... otras configuraciones de apariencia ...&lt;a class="headerlink" href="#otras-configuraciones-de-apariencia" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Este método te proporciona la rapidez y comodidad de un terminal desplegable, pero con toda la potencia y personalización que Kitty ofrece. ¡Es lo mejor de ambos mundos!&lt;/p&gt;</content><category term="Sistemas"></category><category term="kitty"></category><category term="terminal"></category><category term="acceso-rapido"></category><category term="productividad"></category><category term="linux"></category><category term="atajos"></category></entry><entry><title>Atajos de teclado esenciales en Kitty: Dominando tu terminal</title><link href="https://pablocaro.es/atajos-de-teclado-kitty" rel="alternate"></link><published>2025-12-25T12:15:00+01:00</published><updated>2025-12-25T12:15:00+01:00</updated><author><name>Pablo Caro</name></author><id>tag:pablocaro.es,2025-12-25:/atajos-de-teclado-kitty</id><summary type="html">&lt;p&gt;Una guía rápida a los atajos de teclado más útiles de Kitty para optimizar tu flujo de trabajo en la línea de comandos.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Kitty&lt;/strong&gt; es un terminal que brilla por su rendimiento y su gran capacidad de personalización, pero donde realmente se potencia es en su interfaz controlada por teclado. Dominar sus atajos te permitirá navegar, gestionar y manipular tus sesiones de terminal con una eficiencia asombrosa.&lt;/p&gt;
&lt;h2 id="descubre-tus-atajos-show_shortcuts"&gt;Descubre tus atajos: &lt;code&gt;show_shortcuts&lt;/code&gt;&lt;a class="headerlink" href="#descubre-tus-atajos-show_shortcuts" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;La forma más rápida de conocer todos los atajos de teclado configurados en tu instancia de Kitty es usando su propia funcionalidad:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;kitty&lt;span class="w"&gt; &lt;/span&gt;+kitten&lt;span class="w"&gt; &lt;/span&gt;show_shortcuts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Esto abrirá una ventana interactiva donde podrás ver todos los atajos, tanto los predeterminados como los personalizados en tu &lt;code&gt;kitty.conf&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="atajos-esenciales-para-el-dia-a-dia"&gt;Atajos Esenciales para el Día a Día&lt;a class="headerlink" href="#atajos-esenciales-para-el-dia-a-dia" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Aquí te presento algunos de los atajos más útiles y que más te ayudarán a optimizar tu flujo de trabajo:&lt;/p&gt;
&lt;h3 id="gestion-de-ventanas-y-splits-paneles"&gt;Gestión de Ventanas y Splits (Paneles)&lt;a class="headerlink" href="#gestion-de-ventanas-y-splits-paneles" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+enter&lt;/code&gt;: Abre una nueva ventana de Kitty.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+w&lt;/code&gt;: Cierra la ventana actual de Kitty.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+o&lt;/code&gt;: Divide la ventana actual verticalmente (nuevo panel a la derecha).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+e&lt;/code&gt;: Divide la ventana actual horizontalmente (nuevo panel abajo).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+f&lt;/code&gt;: Alterna entre paneles divididos (focus).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+[&lt;/code&gt; / &lt;code&gt;ctrl+shift+]&lt;/code&gt;: Navega entre paneles (izquierda/derecha).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+alt+[&lt;/code&gt; / &lt;code&gt;ctrl+shift+alt+]&lt;/code&gt;: Mueve el panel activo (izquierda/derecha).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="gestion-de-pestanas"&gt;Gestión de Pestañas&lt;a class="headerlink" href="#gestion-de-pestanas" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+t&lt;/code&gt;: Abre una nueva pestaña.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+q&lt;/code&gt;: Cierra la pestaña actual.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+.&lt;/code&gt;: Mueve a la siguiente pestaña.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+,&lt;/code&gt;: Mueve a la pestaña anterior.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+alt+.&lt;/code&gt;: Mueve la pestaña actual a la derecha.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+alt+,&lt;/code&gt;: Mueve la pestaña actual a la izquierda.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="copiar-y-pegar"&gt;Copiar y Pegar&lt;a class="headerlink" href="#copiar-y-pegar" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Kitty tiene su propia implementación de copiar/pegar, que puede ser más fiable que la del sistema cuando trabajas en entornos remotos o con multiplexores:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+c&lt;/code&gt;: Copia el texto seleccionado al portapapeles del sistema.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+v&lt;/code&gt;: Pega el texto del portapapeles del sistema.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="control-de-fuentes-y-apariencia"&gt;Control de Fuentes y Apariencia&lt;a class="headerlink" href="#control-de-fuentes-y-apariencia" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+=&lt;/code&gt; (o &lt;code&gt;+&lt;/code&gt;): Aumenta el tamaño de la fuente.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+-&lt;/code&gt;: Disminuye el tamaño de la fuente.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+backspace&lt;/code&gt;: Restablece el tamaño de la fuente al valor predeterminado.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+shift+k&lt;/code&gt;: Entra en modo "scrollback" (para buscar o seleccionar texto histórico).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="personalizando-tus-atajos-en-kittyconf"&gt;Personalizando tus Atajos en &lt;code&gt;kitty.conf&lt;/code&gt;&lt;a class="headerlink" href="#personalizando-tus-atajos-en-kittyconf" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Puedes añadir o modificar atajos de teclado en tu archivo de configuración &lt;code&gt;~/.config/kitty/kitty.conf&lt;/code&gt; usando la directiva &lt;code&gt;map&lt;/code&gt;. Por ejemplo, para mapear &lt;code&gt;F1&lt;/code&gt; para un script personalizado:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nx"&gt;map&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;f1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;launch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;overlay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;bash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;my_custom_script.sh&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Dominar estos atajos transformará tu interacción con la terminal, haciéndola más fluida e intuitiva. ¡Experimenta y personaliza Kitty para que se adapte perfectamente a tu estilo de trabajo!&lt;/p&gt;</content><category term="Sistemas"></category><category term="kitty"></category><category term="terminal"></category><category term="atajos"></category><category term="teclado"></category><category term="productividad"></category></entry><entry><title>De Yakuake a Kitty: Mi transición a un terminal moderno</title><link href="https://pablocaro.es/de-yakuake-a-kitty" rel="alternate"></link><published>2025-12-25T12:00:00+01:00</published><updated>2025-12-25T12:00:00+01:00</updated><author><name>Pablo Caro</name></author><id>tag:pablocaro.es,2025-12-25:/de-yakuake-a-kitty</id><summary type="html">&lt;p&gt;Explorando las razones y beneficios de cambiar de Yakuake a Kitty para una experiencia de terminal más potente y personalizable.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Durante años, &lt;strong&gt;Yakuake&lt;/strong&gt; ha sido mi terminal de cabecera en entornos de escritorio KDE. Su comodidad de acceso rápido, desplegándose y ocultándose con una simple pulsación de tecla, es innegable. Sin embargo, en mi búsqueda constante de optimización y rendimiento, decidí explorar alternativas, y &lt;strong&gt;Kitty&lt;/strong&gt; emergió como una opción destacada.&lt;/p&gt;
&lt;h2 id="por-que-el-cambio"&gt;¿Por qué el cambio?&lt;a class="headerlink" href="#por-que-el-cambio" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Aunque Yakuake es excelente en su nicho, Kitty ofrece una serie de ventajas que se alinean mejor con las demandas de un flujo de trabajo moderno y exigente:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Rendimiento Acelerado por GPU&lt;/strong&gt;: Kitty está diseñado para aprovechar la tarjeta gráfica, lo que resulta en un renderizado de texto extremadamente rápido y fluido, especialmente noticeable en terminales con mucho scroll o salida de datos intensa.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multiplexación Integrada&lt;/strong&gt;: A diferencia de Yakuake, que se basa en sesiones de pestañas/ventanas tradicionales, Kitty incorpora su propio sistema de multiplexación (similar a &lt;code&gt;tmux&lt;/code&gt; o &lt;code&gt;screen&lt;/code&gt;) que permite dividir ventanas, crear pestañas y organizar paneles de forma nativa y eficiente.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Configurabilidad Extensa&lt;/strong&gt;: &lt;code&gt;kitty.conf&lt;/code&gt; permite una personalización profunda, desde atajos de teclado hasta la apariencia, temas y comportamiento.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Soporte Moderno&lt;/strong&gt;: Excelente soporte para Wayland (el futuro de Linux en el escritorio), ligaduras de fuentes (como las de Fira Code), y un ecosistema de "kittens" (scripts y funcionalidades extendidas).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cross-platform&lt;/strong&gt;: Aunque mi uso principal es en Linux, la capacidad de tener una experiencia de terminal consistente en diferentes sistemas operativos es un plus.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="adaptandose-a-kitty"&gt;Adaptándose a Kitty&lt;a class="headerlink" href="#adaptandose-a-kitty" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;La transición requirió ajustar algunas costumbres, principalmente la forma de gestionar las sesiones y el acceso rápido. Sin embargo, las ventajas superan con creces la curva de aprendizaje inicial. La velocidad, la fluidez y la potencia de las características integradas de Kitty lo convierten en una herramienta indispensable para mi día a día.&lt;/p&gt;
&lt;p&gt;Configurar Kitty es un proceso sencillo a través de su archivo &lt;code&gt;kitty.conf&lt;/code&gt;, donde se definen todos los aspectos del terminal. Exploraremos más sobre su configuración y atajos de teclado en próximas entradas.&lt;/p&gt;
&lt;p&gt;Si buscas llevar tu experiencia de terminal al siguiente nivel, la migración a Kitty es un paso que recomiendo encarecidamente.&lt;/p&gt;</content><category term="Sistemas"></category><category term="kitty"></category><category term="yakuake"></category><category term="terminal"></category><category term="linux"></category><category term="productividad"></category><category term="herramientas"></category></entry><entry><title>Cómo uso git worktrees para trabajo concurrente</title><link href="https://pablocaro.es/como-uso-git-worktrees" rel="alternate"></link><published>2025-07-23T06:12:00+02:00</published><updated>2025-07-23T06:12:00+02:00</updated><author><name>Pablo Caro</name></author><id>tag:pablocaro.es,2025-07-23:/como-uso-git-worktrees</id><summary type="html">&lt;p class="first last"&gt;Un enfoque práctico para usar git worktrees y maximizar la productividad con múltiples contextos de trabajo simultáneos&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Aleksey Kladov comparte su enfoque único para usar git worktrees, que va más allá del simple cambio de ramas y se convierte en una metodología completa para el trabajo concurrente.&lt;/p&gt;
&lt;img alt="Estructura de worktrees" class="align-center" src="https://matklad.github.io/images/worktree-structure.png" /&gt;
&lt;div class="section" id="la-filosofia-central"&gt;
&lt;h2&gt;La filosofía central&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&amp;quot;Git no es un sistema de control de versiones, Git es una caja de herramientas para construir un VCS&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Esta perspectiva cambia completamente cómo pensamos sobre git. En lugar de limitarnos a las funcionalidades básicas, podemos crear nuestro propio flujo de trabajo optimizado.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="los-5-worktrees-especializados"&gt;
&lt;h2&gt;Los 5 worktrees especializados&lt;/h2&gt;
&lt;p&gt;El autor mantiene 5 worktrees, cada uno con un propósito específico:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;strong&gt;main&lt;/strong&gt; - Snapshot de solo lectura
- Reflejo limpio del main remoto
- Referencia para comparaciones
- Nunca se modifica localmente&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;work&lt;/strong&gt; - Espacio de trabajo principal
- Desarrollo activo día a día
- Commits frecuentes con mensajes mínimos
- HEAD desacoplado para máxima flexibilidad&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;review&lt;/strong&gt; - Dedicado a revisiones de código
- Contexto limpio para analizar PRs
- Sin interferir con el trabajo en curso&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fuzz&lt;/strong&gt; - Pruebas de larga duración
- Fuzzing y tests que duran horas
- Corre en paralelo sin bloquear el desarrollo&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scratch&lt;/strong&gt; - Tareas rápidas no relacionadas
- Experimentos
- Fixes urgentes
- Investigaciones puntuales&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Estructura típica de directorios&lt;/span&gt;
~/projects/my-project/
├──&lt;span class="w"&gt; &lt;/span&gt;main/&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# worktree principal&lt;/span&gt;
├──&lt;span class="w"&gt; &lt;/span&gt;work/&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# desarrollo activo&lt;/span&gt;
├──&lt;span class="w"&gt; &lt;/span&gt;review/&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# revisiones&lt;/span&gt;
├──&lt;span class="w"&gt; &lt;/span&gt;fuzz/&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# testing&lt;/span&gt;
└──&lt;span class="w"&gt; &lt;/span&gt;scratch/&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;# experimentos&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="ventajas-del-enfoque"&gt;
&lt;h2&gt;Ventajas del enfoque&lt;/h2&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;&lt;strong&gt;Trabajo verdaderamente concurrente&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Múltiples actividades de codificación simultáneas&lt;/li&gt;
&lt;li&gt;Sin necesidad de stash o branch switching complejo&lt;/li&gt;
&lt;li&gt;Separación limpia de contextos&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Flujo de trabajo sin fricción&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Cambio instantáneo entre tareas&lt;/li&gt;
&lt;li&gt;Commits frecuentes sin presión por mensajes perfectos&lt;/li&gt;
&lt;li&gt;Experimentación libre en HEAD desacoplado&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Paralelización real&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Fuzzing corriendo mientras desarrollas&lt;/li&gt;
&lt;li&gt;Reviews sin interrumpir el trabajo principal&lt;/li&gt;
&lt;li&gt;Tests en background sin bloqueos&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="tecnicas-avanzadas"&gt;
&lt;h2&gt;Técnicas avanzadas&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HEAD desacoplado estratégico&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# En el worktree &amp;#39;work&amp;#39;, trabajar sin rama&lt;/span&gt;
git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;--detach&lt;span class="w"&gt; &lt;/span&gt;HEAD
&lt;span class="c1"&gt;# Commit frecuente, reorganizar después&lt;/span&gt;
git&lt;span class="w"&gt; &lt;/span&gt;commit&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;wip&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Scripts personalizados para operaciones comunes&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Script para crear/cambiar worktrees rápidamente&lt;/span&gt;
&lt;span class="c1"&gt;#!/bin/bash&lt;/span&gt;
git&lt;span class="w"&gt; &lt;/span&gt;worktree&lt;span class="w"&gt; &lt;/span&gt;add&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;../&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$2&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;../&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Flujo de integración&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Desde el worktree &amp;#39;work&amp;#39;&lt;/span&gt;
git&lt;span class="w"&gt; &lt;/span&gt;log&lt;span class="w"&gt; &lt;/span&gt;--oneline&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;# revisar commits&lt;/span&gt;
git&lt;span class="w"&gt; &lt;/span&gt;reset&lt;span class="w"&gt; &lt;/span&gt;HEAD~5&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;# deshacer commits temporales&lt;/span&gt;
git&lt;span class="w"&gt; &lt;/span&gt;add&lt;span class="w"&gt; &lt;/span&gt;-p&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# seleccionar cambios&lt;/span&gt;
git&lt;span class="w"&gt; &lt;/span&gt;commit&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# commit final limpio&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lecciones-clave"&gt;
&lt;h2&gt;Lecciones clave&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;strong&gt;Git es flexible&lt;/strong&gt;: No hay &amp;quot;una forma correcta&amp;quot; de usar git&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Automatiza lo repetitivo&lt;/strong&gt;: Scripts personalizados para operaciones comunes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Separa contextos&lt;/strong&gt;: Cada tipo de trabajo merece su propio espacio&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Commits baratos&lt;/strong&gt;: Commitea frecuentemente, organiza después&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Este enfoque transforma git de una herramienta de versionado en una plataforma completa de gestión de flujo de trabajo, maximizando la productividad a través del trabajo verdaderamente concurrente.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Artículo original&lt;/em&gt;: &lt;a class="reference external" href="https://matklad.github.io/2024/07/25/git-worktrees.html"&gt;How I Use Git Worktrees&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</content><category term="Programación"></category><category term="git"></category><category term="worktrees"></category><category term="flujo-trabajo"></category><category term="productividad"></category></entry></feed>